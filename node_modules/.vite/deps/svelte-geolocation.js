import "./chunk-X7HCJ7ZS.js";
import "./chunk-TDRWH72F.js";
import {
  SvelteComponentDev,
  createEventDispatcher,
  create_slot,
  dispatch_dev,
  get_all_dirty_from_scope,
  get_slot_changes,
  init,
  onDestroy,
  safe_not_equal,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-663KAPRR.js";
import "./chunk-XSLCAIPP.js";
import "./chunk-TYRVL62N.js";

// node_modules/svelte-geolocation/src/Geolocation.svelte
var get_default_slot_changes = (dirty) => ({
  loading: dirty & /*loading*/
  1,
  success: dirty & /*success*/
  8,
  error: dirty & /*error*/
  2,
  notSupported: dirty & /*notSupported*/
  16,
  coords: dirty & /*coords*/
  4
});
var get_default_slot_context = (ctx) => ({
  loading: (
    /*loading*/
    ctx[0]
  ),
  success: (
    /*success*/
    ctx[3]
  ),
  error: (
    /*error*/
    ctx[1]
  ),
  notSupported: (
    /*notSupported*/
    ctx[4]
  ),
  coords: (
    /*coords*/
    ctx[2]
  )
});
function create_fragment(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, loading, success, error, notSupported, coords*/
        8223)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Geolocation", slots, ["default"]);
  let { coords = [-1, -1] } = $$props;
  let { position = {} } = $$props;
  let { options = {} } = $$props;
  let { getPosition = false } = $$props;
  let { watch = false } = $$props;
  let { loading = false } = $$props;
  let { success = false } = $$props;
  let { error = false } = $$props;
  let { notSupported = false } = $$props;
  async function watchPosition(opts) {
    $$invalidate(4, notSupported = false);
    $$invalidate(0, loading = true);
    $$invalidate(1, error = false);
    if (!("geolocation" in navigator)) {
      $$invalidate(4, notSupported = true);
    } else {
      if (watcherId)
        await clearWatcher(watcherId);
      $$invalidate(12, watcherId = navigator.geolocation.watchPosition(handlePosition, handleError, opts));
      return watcherId;
    }
  }
  async function getGeolocationPosition(opts) {
    $$invalidate(4, notSupported = false);
    $$invalidate(0, loading = true);
    $$invalidate(1, error = false);
    if (!("geolocation" in navigator)) {
      $$invalidate(4, notSupported = true);
    } else {
      navigator.geolocation.getCurrentPosition(handlePosition, handleError, opts);
    }
  }
  async function clearWatcher(watcherId2) {
    if (!("geolocation" in navigator)) {
      $$invalidate(4, notSupported = true);
    } else {
      navigator.geolocation.clearWatch(watcherId2);
      watcherId2 = void 0;
    }
  }
  const dispatch = createEventDispatcher();
  let watcherId = void 0;
  let lastPosition = void 0;
  function handlePosition(pos) {
    $$invalidate(2, coords = [pos.coords.longitude, pos.coords.latitude]);
    $$invalidate(5, position = {
      coords: {
        accuracy: pos.coords.accuracy,
        altitude: pos.coords.altitude,
        altitudeAccuracy: pos.coords.altitudeAccuracy,
        heading: pos.coords.heading,
        latitude: pos.coords.latitude,
        longitude: pos.coords.longitude,
        speed: pos.coords.speed
      },
      timestamp: pos.timestamp
    });
    if (!lastPosition || lastPosition.coords.latitude !== pos.coords.latitude || lastPosition.coords.longitude !== pos.coords.longitude) {
      lastPosition = pos;
      dispatch("position", position);
    }
    $$invalidate(0, loading = false);
  }
  function handleError(err) {
    dispatch("error", err);
    $$invalidate(1, error = err);
    $$invalidate(0, loading = false);
  }
  onDestroy(() => {
    if (watcherId)
      clearWatcher(watcherId);
  });
  const writable_props = [
    "coords",
    "position",
    "options",
    "getPosition",
    "watch",
    "loading",
    "success",
    "error",
    "notSupported"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Geolocation> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("coords" in $$props2)
      $$invalidate(2, coords = $$props2.coords);
    if ("position" in $$props2)
      $$invalidate(5, position = $$props2.position);
    if ("options" in $$props2)
      $$invalidate(6, options = $$props2.options);
    if ("getPosition" in $$props2)
      $$invalidate(7, getPosition = $$props2.getPosition);
    if ("watch" in $$props2)
      $$invalidate(8, watch = $$props2.watch);
    if ("loading" in $$props2)
      $$invalidate(0, loading = $$props2.loading);
    if ("success" in $$props2)
      $$invalidate(3, success = $$props2.success);
    if ("error" in $$props2)
      $$invalidate(1, error = $$props2.error);
    if ("notSupported" in $$props2)
      $$invalidate(4, notSupported = $$props2.notSupported);
    if ("$$scope" in $$props2)
      $$invalidate(13, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    coords,
    position,
    options,
    getPosition,
    watch,
    loading,
    success,
    error,
    notSupported,
    watchPosition,
    getGeolocationPosition,
    clearWatcher,
    createEventDispatcher,
    onDestroy,
    dispatch,
    watcherId,
    lastPosition,
    handlePosition,
    handleError
  });
  $$self.$inject_state = ($$props2) => {
    if ("coords" in $$props2)
      $$invalidate(2, coords = $$props2.coords);
    if ("position" in $$props2)
      $$invalidate(5, position = $$props2.position);
    if ("options" in $$props2)
      $$invalidate(6, options = $$props2.options);
    if ("getPosition" in $$props2)
      $$invalidate(7, getPosition = $$props2.getPosition);
    if ("watch" in $$props2)
      $$invalidate(8, watch = $$props2.watch);
    if ("loading" in $$props2)
      $$invalidate(0, loading = $$props2.loading);
    if ("success" in $$props2)
      $$invalidate(3, success = $$props2.success);
    if ("error" in $$props2)
      $$invalidate(1, error = $$props2.error);
    if ("notSupported" in $$props2)
      $$invalidate(4, notSupported = $$props2.notSupported);
    if ("watcherId" in $$props2)
      $$invalidate(12, watcherId = $$props2.watcherId);
    if ("lastPosition" in $$props2)
      lastPosition = $$props2.lastPosition;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*getPosition, watch, options*/
    448) {
      $:
        if (typeof window !== "undefined" && getPosition && watch)
          watchPosition(options);
    }
    if ($$self.$$.dirty & /*getPosition, watch, options*/
    448) {
      $:
        if (typeof window !== "undefined" && getPosition && !watch)
          getGeolocationPosition(options);
    }
    if ($$self.$$.dirty & /*getPosition, loading, error*/
    131) {
      $:
        $$invalidate(3, success = getPosition && !loading && !error);
    }
    if ($$self.$$.dirty & /*getPosition, watch, watcherId*/
    4480) {
      $:
        if ((!getPosition || !watch) && watcherId)
          clearWatcher(watcherId);
    }
  };
  return [
    loading,
    error,
    coords,
    success,
    notSupported,
    position,
    options,
    getPosition,
    watch,
    watchPosition,
    getGeolocationPosition,
    clearWatcher,
    watcherId,
    $$scope,
    slots
  ];
}
var Geolocation = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      coords: 2,
      position: 5,
      options: 6,
      getPosition: 7,
      watch: 8,
      loading: 0,
      success: 3,
      error: 1,
      notSupported: 4,
      watchPosition: 9,
      getGeolocationPosition: 10,
      clearWatcher: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Geolocation",
      options,
      id: create_fragment.name
    });
  }
  get coords() {
    throw new Error("<Geolocation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set coords(value) {
    throw new Error("<Geolocation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Geolocation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Geolocation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Geolocation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Geolocation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getPosition() {
    throw new Error("<Geolocation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getPosition(value) {
    throw new Error("<Geolocation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get watch() {
    throw new Error("<Geolocation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set watch(value) {
    throw new Error("<Geolocation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loading() {
    throw new Error("<Geolocation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loading(value) {
    throw new Error("<Geolocation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get success() {
    throw new Error("<Geolocation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set success(value) {
    throw new Error("<Geolocation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<Geolocation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value) {
    throw new Error("<Geolocation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get notSupported() {
    throw new Error("<Geolocation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notSupported(value) {
    throw new Error("<Geolocation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get watchPosition() {
    return this.$$.ctx[9];
  }
  set watchPosition(value) {
    throw new Error("<Geolocation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getGeolocationPosition() {
    return this.$$.ctx[10];
  }
  set getGeolocationPosition(value) {
    throw new Error("<Geolocation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearWatcher() {
    return this.$$.ctx[11];
  }
  set clearWatcher(value) {
    throw new Error("<Geolocation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Geolocation_default = Geolocation;
export {
  Geolocation_default as default
};
//# sourceMappingURL=svelte-geolocation.js.map
